# Introduction-to-Java
This repository is based on the tasks I solved during the first semester during my studies at CT ITMO.

## Домашнее задание 2. [Сумма чисел](Sum/Sum.java)
1. Разработайте класс Sum, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.
2. Примеры запуска программы: <br/>
  java Sum 1 2 3 <br/>
  **Результат:** 6 <br/>
  java Sum 1 2 -3 <br/>
  **Результат:** 0 <br/>
  java Sum "1 2 3" <br/>
  **Результат:** 6 <br/>
  java Sum "1 2" " 3" <br/>
  **Результат:** 6 <br/>
  java Sum " " <br/>
  **Результат:** 0 <br/>
4. Аргументы могут содержать:
   - цифры;
   - знаки + и -;
   - произвольные [пробельные символы](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#isWhitespace(char)).
5. При выполнении задания можно считать, что для представления входных данных и промежуточных результатов достаточен тип int.
6. Перед выполнением задания ознакомьтесь с документацией к классам [String](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html) и [Integer](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Integer.html).
7. Для отладочного вывода используйте [System.err](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.html#err), тогда он будет игнорироваться проверяющей программой.
> [!NOTE]
> ### Модификация ([Double](Sum/SumDouble.java))
> - Входные данные являются 64-битными числами с формате с плавающей точкой
> - Класс должен иметь имя SumDouble

## Домашнее задание 3. [Реверс](Reverse/Reverse.java)
1. Разработайте класс Reverse, читающий числа из [стандартного ввода](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.html#in) и выводящий их на [стандартный вывод](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.html#out) в обратном порядке.
2. В каждой строке входа содержится некоторое количество целых чисел (возможно ноль). Числа разделены пробелами. Каждое число помещается в тип int.
3. Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке также должен быть обратным к порядку чисел во входе.
4. Вход содержит не более 10⁶ чисел и строк.
5. Для чтения чисел используйте класс [Scanner](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Scanner.html).
6. Примеры работы программы:

| Input | Output |
| :--- | :--- |
| 1 2 <br/> 3 | 3 <br/> 2 1 |
| 3 <br/> 2 1 | 1 2 <br/> 3 |
| 1 <br/><br/> 2 -3 | -3 2 <br/><br/> 1 |
| 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 <br/> 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 | 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 <br/> 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 |

> [!NOTE]
> ### Модификация ([Transpose](Reverse/ReverseTranspose.java))
> - Рассмотрим входные данные как (не полностью определенную) матрицу, выведите ее в транспонированном виде
> - Класс должен иметь имя ReverseTranspose

## Домашнее задание 4. [Статистика слов](WordsSuffix/WordStatInput.java)
1. Разработайте класс WordStatInput, подсчитывающий статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов (') и дефисов (Unicode category [Punctuation](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION), [Dash](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION)). Для подсчета статистики слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Примеры работы программы:

| Input | Output |
| :--- | :--- |
| To be, or not to be, that is the question: | to 2 <br/>be 2 <br/>or 1 <br/>not 1 <br/>that 1 <br/>is 1 <br/>the 1 <br/>question 1 |
| Monday's child is fair of face. <br/>Tuesday's child is full of grace. | monday's 1 <br/>child 2 <br/>is 2 <br/>fair 1 <br/>of 2 <br/>face 1 <br/>tuesday's 1 <br/>full 1 <br/>grace 1 |
| Шалтай-Болтай <br/>Сидел на стене. <br/>Шалтай-Болтай <br/>Свалился во сне. | шалтай-болтай 2 <br/>сидел 1 <br/>на 1 <br/>стене 1 <br/>свалился 1 <br/>во 1 <br/>сне 1 |

> [!NOTE]
> ### Модификация ([WordsSuffix](WordsSuffix/WordsSuffix.java))
> - Выходной файл должен содержать все различные суффиксы длины 3 слов встречающихся во входном файле, в лексикографическом порядке. Слова длины меньшей 3 используются как есть.
> - Класс должен иметь имя WordsSuffix

## Домашнее задание 5. Свой сканер
1. Реализуйте свой аналог класса [Scanner](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Scanner.html) на основе [Reader](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/Reader.html).
2. Примените разработанный Scanner для решения задания «Реверс».
3. Примените разработанный Scanner для решения задания «Статистика слов».
4. Нужно использовать блочное чтение. Код, управляющий чтением, должен быть общим.
5. *Сложный вариант.* Код, выделяющий числа и слова, должен быть общим.
6. Обратите внимание на:
   - Обработку ошибок.
   - На слова/числа, пересекающие границы блоков, особенно — больше одного раза.

> [!Warning]
> Это домашнее задание у меня не сделано, так как была большая загруженность.
> Но в итоге это задание было связано со следующим, так что мне всё-равно пришлось его сделать.

## Домашнее задание 6. [Статистика слов++](Wspp/Wspp.java)
1. Разработайте класс Wspp, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category [Punctuation](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION), [Dash](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION)). Для подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Программа должна работать за линейное от размера входного файла время.
6. Для реализации программы используйте Collections Framework.
7. *Сложный вариант.* Реализуйте и примените класс IntList, компактно хранящий список целых чисел.
8. Примеры работы программы:

| Input | Output |
| :--- | :--- |
| To be, or not to be, that is the question: | to 2 1 5 <br/>be 2 2 6 <br/>or 1 3 <br/>not 1 4 <br/>that 1 7 <br/>is 1 8 <br/>the 1 9 <br/>question 1 10 |
| Monday's child is fair of face. <br/>Tuesday's child is full of grace. | monday's 1 1 <br/>child 2 2 8 <br/>is 2 3 9 <br/>fair 1 4 <br/>of 2 5 11 <br/>face 1 6 <br/>tuesday's 1 7 <br/>full 1 10 <br/>grace 1 12 |
| Шалтай-Болтай <br/>Сидел на стене. <br/>Шалтай-Болтай <br/>Свалился во сне. | шалтай-болтай 2 1 5 <br/>сидел 1 2 <br/>на 1 3 <br/>стене 1 4 <br/>свалился 1 6 <br/>во 1 7 <br/>сне 1 8 |

> [!NOTE]
> ### Модификация ([CountPosition](Wspp/WsppCountPosition.java))
> - В выходном файле слова должны быть упорядочены по возрастанию числа вхождений, а при равном числе вхождений – по порядку первого вхождения во входном файле.
> - Вместо номеров вхождений во всем файле надо указывать <номер строки>:<номер в строке>
> - Класс должен иметь имя WsppCountPosition

## Домашнее задание 7. [Разметка](Markdown/Markdown)
1. Разработайте набор классов для текстовой разметки.
2. Класс Paragraph может содержать произвольное число других элементов разметки и текстовых элементов.
3. Класс Text – текстовый элемент.
4. Классы разметки Emphasis, Strong, Strikeout – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
5. Все классы должны реализовывать метод toMarkdown([StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html)), который должен генерировать [Markdown](https://ru.wikipedia.org/wiki/Markdown)-разметку по следующим правилам:
   1. текстовые элементы выводятся как есть;
   2. выделенный текст окружается символами '*';
   3. сильно выделенный текст окружается символами '__';
   4. зачеркнутый текст окружается символами '~'.
6. Следующий код должен успешно компилироваться: <br/>
   ```
   Paragraph paragraph = new Paragraph(List.of(
       new Strong(List.of(
           new Text("1"),
           new Strikeout(List.of(
               new Text("2"),
               new Emphasis(List.of(
                   new Text("3"),
                   new Text("4")
               )),
               new Text("5")
           )),
           new Text("6")
       ))
   ));
   ```
   Вызов paragraph.toMarkdown(new StringBuilder()) должен заполнять переданный StringBuilder следующим содержимым: <br/>
   \_\_1\~2\*34\*5\~6\_\_
7. Разработанные классы должны находиться в пакете markup.

> [!NOTE]
> ### Модификация ([Tex](Markdown/TexMod))
> - Дополнительно реализуйте метод toTex, генерирующий TeX-разметку:
>   - выделеный текст заключается в \emph{ и };
>   - сильно выделеный текст заключается в \textbf{ и };
>   - зачеркнутый текст заключается в \textst{ и }.

## Домашнее задание 8. Чемпионат
1. Решите как можно больше задач Чемпионата северо-запада России по программированию 2019.
2. Материалы соревнования:
   - PCMS: Java. North-Western Russia Regional Contest - 2019
   - Условия задач
   - Разбор задач
3. Задачи для решения

   | Задача | Тема | Сложность|
   | :--- | :---: | :---: |
   | A.	Accurate Movement | Формула | 5 |
   | B.	Bad Treap | Циклы | 10 |
   | C.	Cross-Stitch | Графы | 40 |
   | D.	Double Palindrome | Массивы | 40 |
   | E.	Equidistant | Деревья | 30 |
   | H.	High Load Database | Массивы | 20 |
   | I.	Ideal Pyramid | Циклы | 15 |
   | J.	Just the Last Digit | Матрицы | 20 |
   | K.	King’s Children | Массивы | 40 |
   | M.	Managing Difficulties | Коллекции | 10 |
4. Рекомендуемое время выполнения задания: 3 часа

> [!Warning]
> Это домашнее задание у меня не сделано, так как была большая загруженность.

## Домашнее задание 9. [Markdown to HTML](Md2Html/Md2Html.java)
1. Разработайте конвертер из [Markdown](https://ru.wikipedia.org/wiki/Markdown)-разметки в [HTML](https://ru.wikipedia.org/wiki/HTML).
2. Конвертер должен поддерживать следующие возможности:
   1. Абзацы текста разделяются пустыми строками.
   2. Элементы строчной разметки: выделение (* или _), сильное выделение (** или __), зачеркивание (--), код (`)
   3. Заголовки (# * уровень заголовка)
3. Конвертер должен называться md2html.Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
4. При выполнении этого ДЗ можно повторно использовать код ДЗ markup.
5. Конвертер может хранить исходные и сконвертированные данные в памяти, в том числе, одновременно.
6. Пример
   - Входной файл
   ```
   # Заголовок первого уровня

   ## Второго

   ### Третьего ## уровня

   #### Четвертого
   # Все еще четвертого

   Этот абзац текста,
   содержит две строки.
   
       # Может показаться, что это заголовок.
   Но нет, это абзац начинающийся с `#`.

   #И это не заголовок.
   
   ###### Заголовки могут быть многострочными
   (и с пропуском заголовков предыдущих уровней)
   
   Мы все любим *выделять* текст _разными_ способами.
   **Сильное выделение**, используется гораздо реже,
   но __почему бы и нет__?
   Немного --зачеркивания-- еще ни кому не вредило.
   Код представляется элементом `code`.
   
   Обратите внимание, как экранируются специальные
   HTML-символы, такие как `<`, `>` и `&`.
   
   Знаете ли вы, что в Markdown, одиночные * и _
   не означают выделение?
   Они так же могут быть заэкранированы
   при помощи обратного слэша: \*.
   
   
   
   Лишние пустые строки должны игнорироваться.
   
   Любите ли вы *вложеные __выделения__* так,
   как __--люблю--__ их я?
   ```
   - Выходной файл
   ```
   <h1>Заголовок первого уровня</h1>
   <h2>Второго</h2>
   <h3>Третьего ## уровня</h3>
   <h4>Четвертого
   # Все еще четвертого</h4>
   <p>Этот абзац текста,
   содержит две строки.</p>
   <p>    # Может показаться, что это заголовок.
   Но нет, это абзац начинающийся с <code>#</code>.</p>
   <p>#И это не заголовок.</p>
   <h6>Заголовки могут быть многострочными
   (и с пропуском заголовков предыдущих уровней)</h6>
   <p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
   <strong>Сильное выделение</strong>, используется гораздо реже,
   но <strong>почему бы и нет</strong>?
   Немного <s>зачеркивания</s> еще ни кому не вредило.
   Код представляется элементом <code>code</code>.</p>
   <p>Обратите внимание, как экранируются специальные
   HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
   <p>Знаете ли вы, что в Markdown, одиночные * и _
   не означают выделение?
   Они так же могут быть заэкранированы
   при помощи обратного слэша: *.</p>
   <p>Лишние пустые строки должны игнорироваться.</p>
   <p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
   как <strong><s>люблю</s></strong> их я?</p>
   ```
### [Реальная разметка](https://codesandbox.io/p/sandbox/czpv6s)

> [!NOTE]
> ### Модификация ([Underline](Md2Html/Md2Html.java))
> - Добавьте поддержку ++подчеркивания++: <u>подчеркивания</u>

## Домашнее задание 10. [Игра m,n,k](TicTacToe/Main.java)
В этом домашнем задании вы можете пользоваться кодом, написанным на лекции. Он есть на сайте курса и в репозитории prog-intro-2021-solutions.

1. Реализуйте [игру m,n,k](https://en.wikipedia.org/wiki/M,n,k-game) (k в ряд на доске m×n).
2. Добавьте обработку ошибок ввода пользователя. В случае ошибочного хода пользователь должен иметь возможность сделать другой ход.
3. Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
4. Простая версия. Доска может производить обработку хода за O(nmk).
5. *Сложная версия.*
   - Доска должна производить обработку хода (проверку корректности, изменение состояния и определение результата) за O(k).
   - Предотвратите жульничество: у игрока не должно быть возможности достать Board из Position.
6. *Бонусная версия.* Реализуйте Winner — игрок, который выигрывает всегда, когда это возможно (против любого соперника).

> [!NOTE]
> ### Модификация ([Дополнительные ходы](TicTacToe/Main.java))
> - Если в результате хода игрока на доске появляется новая последовательность из 4+ одинаковых символов, то он делает дополнительный ход.
> - Игрок может сделать несколько дополнительных ходов подряд.

> [!IMPORTANT]
> Следующие задания связаны между собой, поэтому лежат в одном месте

## Домашнее задание 11. [Выражения](Expression/solution/src/expression/)
1. Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide для вычисления выражений с одной переменной в типе int (интерфейс Expression).
2. Классы должны позволять составлять выражения вида
   ```
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).evaluate(5)
   ```         
   При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу evaluate. Таким образом, результатом вычисления приведенного примера должно стать число 7. <br/>
3. Метод toString должен выдавать запись выражения в полноскобочной форме. Например
   ```
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).toString()
   ```
   должен выдавать ((2 * x) - 3). <br/>
4. Сложный вариант. Метод toMiniString (интерфейс ToMiniString) должен выдавать выражение с минимальным числом скобок. Например
   ```
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).toMiniString()
   ```
   должен выдавать 2 * x - 3.
5. Реализуйте метод equals, проверяющий, что два выражения совпадают. Например,
   ```
   new Multiply(new Const(2), new Variable("x"))
       .equals(new Multiply(new Const(2), new Variable("x")))
   ```
      должно выдавать true, а <br/>
   ```
   new Multiply(new Const(2), new Variable("x"))
       .equals(new Multiply(new Variable("x"), new Const(2)))
   ```
   должно выдавать false. <br/>
6. Для тестирования программы должен быть создан класс Main, который вычисляет значение выражения x2−2x+1, для x, заданного в командной строке.
7. При выполнении задания следует обратить внимание на:
   - Выделение общего интерфейса создаваемых классов.
   - Выделение абстрактного базового класса для бинарных операций.

> [!NOTE]
> ### Модификация ([Triple](Expression/solution/src/expression/))
> - Дополнительно реализуйте поддержку выражений с тремя переменными: x, y и z.
> - Интерфейс TripleExpression.

## Домашнее задание 12. [Разбор выражений](Expression/solution/src/expression/)
1. Доработайте предыдущее домашнее задание так, чтобы выражение строилось по записи вида
   x * (x - 2)*x + 1 <br/>
2. В записи выражения могут встречаться:
   - бинарные операции: умножение *, деление /, сложение + и вычитание -;
   - унарный минус -;
   - переменные x, y и z;
   - целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
   - круглые скобки для явного обозначения приоритета операций;
   - произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).
3. Приоритет операций, начиная с наивысшего
   1.унарный минус;
   2. умножение и деление;
   3. сложение и вычитание.
4. Разбор выражений рекомендуется производить [методом рекурсивного спуска](https://ru.wikibooks.org/wiki/Реализации_алгоритмов/Метод_рекурсивного_спуска).
   - Алгоритм должен работать за линейное время.
   - Лексический анализ (токенизация) не требуется.

> [!NOTE]
> ### Модификация ([SetClear](Expression/solution/src/expression/))
> - Дополнительно реализуйте бинарные операции (минимальный приоритет):
>   - set – установка бита, 2 set 3 равно 10;
>   - clear – сброс бита, 10 clear 3 равно 2.

## Домашнее задание 13. [Обработка ошибок](Expression/solution/src/expression/)
1. Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:
   - ошибки разбора выражений;
   - ошибки вычисления выражений.
2. Для выражения 1000000*x*x*x*x*x/(x-1) вывод программы должен иметь следующий вид:

   | x | f |
   | :---: | :--- |
   | 0 | 0 |
   | 1 | division by zero |
   | 2 | 32000000 |
   | 3 | 121500000 |
   | 4 | 341333333 |
   | 5 | overflow |
   | 6 | overflow |
   | 7 | overflow |
   | 8 | overflow |
   | 9 | overflow |
   | 10 | overflow |

   Результат division by zero (overflow) означает, что в процессе вычисления произошло деление на ноль (переполнение). <br/>
3. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4. Человеко-читаемые сообщения об ошибках должны выводиться на консоль.
5. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

> [!NOTE]
> ### Модификация ([SetClear](Expression/solution/src/expression/))
> - Дополнительно реализуйте бинарные операции (минимальный приоритет):
>   - set – установка бита, 2 set 3 равно 10;
>   - clear – сброс бита, 10 clear 3 равно 2.

## Домашнее задание 14. Вычисление в различных типах
Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.
1. Создайте класс expression.generic.GenericTabulator, реализующий интерфейс expression.generic.Tabulator:
   ```
    public interface Tabulator {
        Object[][][] tabulate(
            String mode, String expression, 
            int x1, int x2, int y1, int y2, int z1, int z2
        ) throws Exception;
    }
   ```
   Аргументы
   - mode — режим работы
   
   | Режим | Тип |
   | :---: | :--- |
   | i | int с детекцией переполнений |
   | d | double |
   | bi | [BigInteger](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/math/BigInteger.html) |
   - expression — вычисляемое выражение;
   - x1, x2; y1, y2; z1, z2 — диапазоны изменения переменных (включительно).
   Возвращаемое значение — таблица значений функции, где R[i][j][k] соответствует x = x1 + i, y = y1 + j, z = z1 + k. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть null.

2. Доработайте интерфейс командной строки:
   - Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производиться вычисления:
   
   | Опция | Тип |
   | :---: | :--- |
   | i | int с детекцией переполнений |
   | d | double |
   | bi | [BigInteger](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/math/BigInteger.html) |
   - Вторым аргументом командной строки программа должна принимать выражение для вычисления.
   - Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.
3. Реализация не должна содержать [непроверяемых преобразований типов](https://docs.oracle.com/javase/specs/jls/se21/html/jls-5.html#jls-5.1.9).
4. Реализация не должна использовать аннотацию [@SuppressWarnings](https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.6.4.5).
5. При выполнении задания следует обратить внимание на простоту добавления новых типов и операций. <br/><br/>

> [!WARNING]
> Это задание я не делал, так как к тому времени уже закрылся.
